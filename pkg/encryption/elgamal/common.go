package elgamal

import (
	"crypto/ecdsa"
	"crypto/sha256"
	"github.com/coinbase/kryptology/pkg/core/curves"
	"golang.org/x/crypto/hkdf"
	"io"
)

// H is a random point on the eliptic curve that is unrelated to G.
const H_STRING = "gPt25pi0eDphSiXWu0BIeIvyVATCtwhslTqfqvNhW2c"

func (teg TwistedElGamal) KeyGen(privateKey ecdsa.PrivateKey, denom string) (*KeyPair, error) {
	// Fixed base point H
	H := teg.GetH()

	s, err := getPrivateKey(privateKey, denom)
	if err != nil {
		return nil, err
	}

	// Compute the public key P = s^(-1) * H
	sInv, _ := s.Invert()

	P := H.Mul(sInv) // P = s^(-1) * H

	return &KeyPair{
		PublicKey:  P,
		PrivateKey: s,
	}, nil
}

func (teg TwistedElGamal) GetG() curves.Point {
	return curves.Point.Generator(teg.curve.Point)
}

func (teg TwistedElGamal) GetH() curves.Point {
	bytes := []byte(H_STRING)
	return teg.curve.Point.Hash(bytes)
}

func getPrivateKey(privateKey ecdsa.PrivateKey, denom string) (curves.Scalar, error) {
	// Convert the ECDSA private key to bytes
	privKeyBytes := privateKey.D.Bytes()

	// Hash the denom to get a salt.
	salt := sha256.Sum256([]byte(denom))

	// Create an HKDF reader using SHA-256
	hkdf := hkdf.New(sha256.New, privKeyBytes, salt[:], []byte("elgamal scalar derivation"))

	// Generate 64 bytes of randomness from HKDF output
	var scalarBytes [64]byte
	_, err := io.ReadFull(hkdf, scalarBytes[:])
	if err != nil {
		return nil, err
	}

	// Initialize the scalar (private key) using the generated bytes
	s, err := curves.ED25519().Scalar.SetBytesWide(scalarBytes[:])
	if err != nil {
		return nil, err
	}

	return s, nil
}
