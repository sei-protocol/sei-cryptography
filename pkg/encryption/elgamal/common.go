package elgamal

import (
	"crypto/ecdsa"
	"crypto/rand"
	"crypto/sha256"
	"github.com/ethereum/go-ethereum/crypto/secp256k1"
	"io"

	"github.com/coinbase/kryptology/pkg/core/curves"
	"golang.org/x/crypto/hkdf"
)

// H_STRING H is a random point on the elliptic curve that is unrelated to G.
const H_STRING = "gPt25pi0eDphSiXWu0BIeIvyVATCtwhslTqfqvNhW2c"

// GenerateKey generates a new ECDSA key pair.
func GenerateKey() (*ecdsa.PrivateKey, error) {
	return ecdsa.GenerateKey(secp256k1.S256(), rand.Reader)
}

// KeyGen generates a new key pair for the Twisted ElGamal encryption scheme.
func (teg TwistedElGamal) KeyGen(privateKey ecdsa.PrivateKey, denom string) (*KeyPair, error) {
	// Fixed base point H
	H := teg.GetH()

	s, err := teg.getPrivateKey(privateKey, denom)
	if err != nil {
		return nil, err
	}

	// Compute the public key P = s^(-1) * H
	sInv, _ := s.Invert()

	P := H.Mul(sInv) // P = s^(-1) * H

	return &KeyPair{
		PublicKey:  P,
		PrivateKey: s,
	}, nil
}

// GetG returns the generator point G for the TwistedElGamal instance.
// This is derived from the underlying elliptic curve's generator point.
func (teg TwistedElGamal) GetG() curves.Point {
	return curves.Point.Generator(teg.curve.Point)
}

// GetH returns the hashed point H for the TwistedElGamal instance.
// The hash is computed using a predefined string constant H_STRING.
// This point is used as part of the ElGamal encryption scheme.
func (teg TwistedElGamal) GetH() curves.Point {
	bytes := []byte(H_STRING)
	return teg.curve.Point.Hash(bytes)
}

// getPrivateKey derives a private key for the ElGamal cryptosystem.
// It takes an ECDSA private key and a denomination string to generate the scalar.
func (teg TwistedElGamal) getPrivateKey(privateKey ecdsa.PrivateKey, denom string) (curves.Scalar, error) {
	// Convert the ECDSA private key to bytes
	privKeyBytes := privateKey.D.Bytes()

	// Hash the denom to get a salt.
	salt := sha256.Sum256([]byte(denom))

	// Create an HKDF reader using SHA-256
	hkdf := hkdf.New(sha256.New, privKeyBytes, salt[:], []byte("elgamal scalar derivation"))

	// Generate 64 bytes of randomness from HKDF output
	var scalarBytes [64]byte
	_, err := io.ReadFull(hkdf, scalarBytes[:])
	if err != nil {
		return nil, err
	}

	// Initialize the scalar (private key) using the generated bytes
	s, err := teg.curve.Scalar.SetBytesWide(scalarBytes[:])
	if err != nil {
		return nil, err
	}

	return s, nil
}
